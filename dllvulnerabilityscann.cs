using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.Win32;

namespace DllForwardAudit
{
    public sealed class VulnerabilityScanner
    {
        private static readonly HashSet<string> KnownDlls = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "ntdll.dll", "kernel32.dll", "kernelbase.dll", "user32.dll", "gdi32.dll",
            "winspool.drv", "comdlg32.dll", "advapi32.dll", "shell32.dll", "ole32.dll",
            "oleaut32.dll", "version.dll", "lz32.dll", "winmm.dll", "mpr.dll",
            "ws2_32.dll", "wininet.dll", "shfolder.dll", "shlwapi.dll", "comctl32.dll",
            "psapi.dll", "msimg32.dll", "setupapi.dll", "wldap32.dll", "cfgmgr32.dll",
            "devobj.dll", "imm32.dll", "powrprof.dll", "secur32.dll", "netapi32.dll",
            "userenv.dll", "difxapi.dll", "msvcrt.dll", "clbcatq.dll"
        };

        private static readonly string[] SystemPaths = {
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            Environment.GetFolderPath(Environment.SpecialFolder.SystemX86),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Windows), "SysWOW64")
        };

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr LoadLibrary(string lpFileName);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool FreeLibrary(IntPtr hModule);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

        [DllImport("imagehlp.dll", SetLastError = true)]
        private static extern IntPtr ImageDirectoryEntryToData(IntPtr baseAddress, bool mappedAsImage, ushort directoryEntry, out uint size);

        [StructLayout(LayoutKind.Sequential)]
        private struct IMAGE_DOS_HEADER
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
            public char[] e_magic;
            public UInt16 e_cblp;
            public UInt16 e_cp;
            public UInt16 e_crlc;
            public UInt16 e_cparhdr;
            public UInt16 e_minalloc;
            public UInt16 e_maxalloc;
            public UInt16 e_ss;
            public UInt16 e_sp;
            public UInt16 e_csum;
            public UInt16 e_ip;
            public UInt16 e_cs;
            public UInt16 e_lfarlc;
            public UInt16 e_ovno;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public UInt16[] e_res1;
            public UInt16 e_oemid;
            public UInt16 e_oeminfo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
            public UInt16[] e_res2;
            public Int32 e_lfanew;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct IMAGE_NT_HEADERS
        {
            public UInt32 Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER OptionalHeader;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct IMAGE_FILE_HEADER
        {
            public UInt16 Machine;
            public UInt16 NumberOfSections;
            public UInt32 TimeDateStamp;
            public UInt32 PointerToSymbolTable;
            public UInt32 NumberOfSymbols;
            public UInt16 SizeOfOptionalHeader;
            public UInt16 Characteristics;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct IMAGE_OPTIONAL_HEADER
        {
            public UInt16 Magic;
            public Byte MajorLinkerVersion;
            public Byte MinorLinkerVersion;
            public UInt32 SizeOfCode;
            public UInt32 SizeOfInitializedData;
            public UInt32 SizeOfUninitializedData;
            public UInt32 AddressOfEntryPoint;
            public UInt32 BaseOfCode;
            public UInt64 ImageBase;
            public UInt32 SectionAlignment;
            public UInt32 FileAlignment;
            public UInt16 MajorOperatingSystemVersion;
            public UInt16 MinorOperatingSystemVersion;
            public UInt16 MajorImageVersion;
            public UInt16 MinorImageVersion;
            public UInt16 MajorSubsystemVersion;
            public UInt16 MinorSubsystemVersion;
            public UInt32 Win32VersionValue;
            public UInt32 SizeOfImage;
            public UInt32 SizeOfHeaders;
            public UInt32 CheckSum;
            public UInt16 Subsystem;
            public UInt16 DllCharacteristics;
            public UInt64 SizeOfStackReserve;
            public UInt64 SizeOfStackCommit;
            public UInt64 SizeOfHeapReserve;
            public UInt64 SizeOfHeapCommit;
            public UInt32 LoaderFlags;
            public UInt32 NumberOfRvaAndSizes;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public IMAGE_DATA_DIRECTORY[] DataDirectory;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct IMAGE_DATA_DIRECTORY
        {
            public UInt32 VirtualAddress;
            public UInt32 Size;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct IMAGE_EXPORT_DIRECTORY
        {
            public UInt32 Characteristics;
            public UInt32 TimeDateStamp;
            public UInt16 MajorVersion;
            public UInt16 MinorVersion;
            public UInt32 Name;
            public UInt32 Base;
            public UInt32 NumberOfFunctions;
            public UInt32 NumberOfNames;
            public UInt32 AddressOfFunctions;
            public UInt32 AddressOfNames;
            public UInt32 AddressOfNameOrdinals;
        }

        public sealed class ForwardEntry
        {
            public string SourceDll { get; set; }
            public string SourceFunction { get; set; }
            public string TargetDll { get; set; }
            public string TargetFunction { get; set; }
            public bool IsVulnerable { get; set; }
            public string RiskLevel { get; set; }
            public bool IsSigned { get; set; }
            public string FilePath { get; set; }
        }

        public sealed class ScanResult
        {
            public List<ForwardEntry> VulnerableForwards { get; set; } = new List<ForwardEntry>();
            public List<ForwardEntry> AllForwards { get; set; } = new List<ForwardEntry>();
            public Dictionary<string, bool> TestedSideloads { get; set; } = new Dictionary<string, bool>();
            public int TotalFilesScanned { get; set; }
            public TimeSpan ScanDuration { get; set; }
            public string SystemVersion { get; set; }
            public DateTime ScanTimestamp { get; set; } = DateTime.UtcNow;
        }

        public async Task<ScanResult> PerformFullSystemScanAsync()
        {
            var startTime = DateTime.UtcNow;
            var result = new ScanResult
            {
                SystemVersion = Environment.OSVersion.ToString()
            };

            var allDlls = new ConcurrentBag<string>();
            var scanTasks = SystemPaths.Select(async path =>
            {
                if (Directory.Exists(path))
                {
                    await Task.Run(() =>
                    {
                        var dlls = Directory.GetFiles(path, "*.dll", SearchOption.TopDirectoryOnly)
                            .Where(f => IsValidPeFile(f));
                        foreach (var dll in dlls)
                        {
                            allDlls.Add(dll);
                        }
                    });
                }
            });

            await Task.WhenAll(scanTasks);
            var dllArray = allDlls.ToArray();
            result.TotalFilesScanned = dllArray.Length;

            var allForwards = new ConcurrentBag<ForwardEntry>();
            var processingTasks = dllArray.Select(async dll =>
            {
                await Task.Run(() =>
                {
                    var forwards = ExtractForwardedExports(dll);
                    foreach (var forward in forwards)
                    {
                        allForwards.Add(forward);
                    }
                });
            });

            await Task.WhenAll(processingTasks);
            result.AllForwards = allForwards.ToList();
            result.VulnerableForwards = IdentifyVulnerableForwards(result.AllForwards);
            result.TestedSideloads = await TestSideloadingVulnerabilitiesAsync(result.VulnerableForwards.Take(10));
            result.ScanDuration = DateTime.UtcNow - startTime;

            return result;
        }

        private bool IsValidPeFile(string filePath)
        {
            try
            {
                using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);
                var buffer = new byte[2];
                fs.Read(buffer, 0, 2);
                return buffer[0] == 0x4D && buffer[1] == 0x5A;
            }
            catch
            {
                return false;
            }
        }

        private List<ForwardEntry> ExtractForwardedExports(string dllPath)
        {
            var forwards = new List<ForwardEntry>();
            
            try
            {
                using var fs = new FileStream(dllPath, FileMode.Open, FileAccess.Read);
                using var br = new BinaryReader(fs);

                var dosHeader = ReadStruct<IMAGE_DOS_HEADER>(br);
                if (dosHeader.e_magic[0] != 'M' || dosHeader.e_magic[1] != 'Z')
                    return forwards;

                fs.Seek(dosHeader.e_lfanew, SeekOrigin.Begin);
                var ntHeaders = ReadStruct<IMAGE_NT_HEADERS>(br);

                if (ntHeaders.Signature != 0x00004550)
                    return forwards;

                var exportDir = ntHeaders.OptionalHeader.DataDirectory[0];
                if (exportDir.Size == 0)
                    return forwards;

                fs.Seek(RvaToFileOffset(exportDir.VirtualAddress, ntHeaders, br), SeekOrigin.Begin);
                var exportTable = ReadStruct<IMAGE_EXPORT_DIRECTORY>(br);

                var namesOffset = RvaToFileOffset(exportTable.AddressOfNames, ntHeaders, br);
                var functionsOffset = RvaToFileOffset(exportTable.AddressOfFunctions, ntHeaders, br);
                var ordinalsOffset = RvaToFileOffset(exportTable.AddressOfNameOrdinals, ntHeaders, br);

                for (int i = 0; i < exportTable.NumberOfNames; i++)
                {
                    fs.Seek(namesOffset + i * 4, SeekOrigin.Begin);
                    var nameRva = br.ReadUInt32();
                    
                    fs.Seek(ordinalsOffset + i * 2, SeekOrigin.Begin);
                    var ordinal = br.ReadUInt16();

                    fs.Seek(functionsOffset + ordinal * 4, SeekOrigin.Begin);
                    var functionRva = br.ReadUInt32();

                    if (functionRva >= exportDir.VirtualAddress && 
                        functionRva < exportDir.VirtualAddress + exportDir.Size)
                    {
                        fs.Seek(RvaToFileOffset(nameRva, ntHeaders, br), SeekOrigin.Begin);
                        var functionName = ReadNullTerminatedString(br);

                        fs.Seek(RvaToFileOffset(functionRva, ntHeaders, br), SeekOrigin.Begin);
                        var forwardString = ReadNullTerminatedString(br);

                        if (ParseForwardString(forwardString, out var targetDll, out var targetFunction))
                        {
                            forwards.Add(new ForwardEntry
                            {
                                SourceDll = Path.GetFileName(dllPath),
                                SourceFunction = functionName,
                                TargetDll = targetDll,
                                TargetFunction = targetFunction,
                                IsSigned = IsFileDigitallySigned(dllPath),
                                FilePath = dllPath
                            });
                        }
                    }
                }
            }
            catch (Exception)
            {
              
            }

            return forwards;
        }

        private T ReadStruct<T>(BinaryReader reader) where T : struct
        {
            var bytes = reader.ReadBytes(Marshal.SizeOf<T>());
            var handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            try
            {
                return (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));
            }
            finally
            {
                handle.Free();
            }
        }

        private long RvaToFileOffset(uint rva, IMAGE_NT_HEADERS ntHeaders, BinaryReader reader)
        {
            var currentPos = reader.BaseStream.Position;
            reader.BaseStream.Seek(Marshal.OffsetOf<IMAGE_NT_HEADERS>("OptionalHeader").ToInt64() + 
                                  ntHeaders.FileHeader.SizeOfOptionalHeader + 
                                  Marshal.SizeOf<IMAGE_DOS_HEADER>() + 4 + 
                                  Marshal.SizeOf<IMAGE_FILE_HEADER>(), SeekOrigin.Begin);

            for (int i = 0; i < ntHeaders.FileHeader.NumberOfSections; i++)
            {
                var virtualAddress = reader.ReadUInt32();
                var virtualSize = reader.ReadUInt32();
                var rawDataPtr = reader.ReadUInt32();
                var rawDataSize = reader.ReadUInt32();
                reader.ReadBytes(32); // Skip remaining section header

                if (rva >= virtualAddress && rva < virtualAddress + virtualSize)
                {
                    reader.BaseStream.Position = currentPos;
                    return rawDataPtr + (rva - virtualAddress);
                }
            }

            reader.BaseStream.Position = currentPos;
            return rva;
        }

        private string ReadNullTerminatedString(BinaryReader reader)
        {
            var sb = new StringBuilder();
            byte b;
            while ((b = reader.ReadByte()) != 0)
            {
                sb.Append((char)b);
            }
            return sb.ToString();
        }

        private bool ParseForwardString(string forwardString, out string targetDll, out string targetFunction)
        {
            targetDll = null;
            targetFunction = null;

            var dotIndex = forwardString.IndexOf('.');
            if (dotIndex == -1)
                return false;

            targetDll = forwardString.Substring(0, dotIndex);
            if (!targetDll.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
                targetDll += ".dll";

            targetFunction = forwardString.Substring(dotIndex + 1);
            return !string.IsNullOrEmpty(targetDll) && !string.IsNullOrEmpty(targetFunction);
        }

        private List<ForwardEntry> IdentifyVulnerableForwards(List<ForwardEntry> allForwards)
        {
            var vulnerableForwards = new List<ForwardEntry>();

            foreach (var forward in allForwards)
            {
                var isVulnerable = !KnownDlls.Contains(forward.TargetDll) &&
                                 forward.IsSigned &&
                                 !IsSystemDll(forward.TargetDll);

                if (isVulnerable)
                {
                    forward.IsVulnerable = true;
                    forward.RiskLevel = CalculateRiskLevel(forward);
                    vulnerableForwards.Add(forward);
                }
            }

            return vulnerableForwards.OrderByDescending(f => GetRiskScore(f.RiskLevel)).ToList();
        }

        private bool IsSystemDll(string dllName)
        {
            return SystemPaths.Any(path => File.Exists(Path.Combine(path, dllName)));
        }

        private string CalculateRiskLevel(ForwardEntry forward)
        {
            var score = 0;

            if (forward.IsSigned) score += 3;
            if (!IsSystemDll(forward.TargetDll)) score += 4;
            if (IsCommonlyUsedFunction(forward.SourceFunction)) score += 2;
            if (HasHighPrivilegeContext(forward.SourceDll)) score += 3;

            return score switch
            {
                >= 8 => "CRITICAL",
                >= 6 => "HIGH",
                >= 4 => "MEDIUM",
                _ => "LOW"
            };
        }

        private int GetRiskScore(string riskLevel)
        {
            return riskLevel switch
            {
                "CRITICAL" => 4,
                "HIGH" => 3,
                "MEDIUM" => 2,
                "LOW" => 1,
                _ => 0
            };
        }

        private bool IsCommonlyUsedFunction(string functionName)
        {
            var commonFunctions = new[] { "SetAuditingInterface", "Initialize", "GetProcAddress", 
                                        "LoadLibrary", "CreateFile", "RegOpenKey" };
            return commonFunctions.Any(f => functionName.Contains(f, StringComparison.OrdinalIgnoreCase));
        }

        private bool HasHighPrivilegeContext(string dllName)
        {
            var privilegedDlls = new[] { "keyiso", "lsass", "winlogon", "services", "system32" };
            return privilegedDlls.Any(d => dllName.Contains(d, StringComparison.OrdinalIgnoreCase));
        }

        private async Task<Dictionary<string, bool>> TestSideloadingVulnerabilitiesAsync(IEnumerable<ForwardEntry> vulnerableForwards)
        {
            var results = new Dictionary<string, bool>();
            var testDir = Path.Combine(Path.GetTempPath(), $"DllAudit_{Guid.NewGuid():N}");

            try
            {
                Directory.CreateDirectory(testDir);

                foreach (var forward in vulnerableForwards)
                {
                    var testKey = $"{forward.SourceDll}->{forward.TargetDll}";
                    var isExploitable = await TestForwardSideloadAsync(forward, testDir);
                    results[testKey] = isExploitable;
                }
            }
            finally
            {
                if (Directory.Exists(testDir))
                {
                    try
                    {
                        Directory.Delete(testDir, true);
                    }
                    catch { }
                }
            }

            return results;
        }

        private async Task<bool> TestForwardSideloadAsync(ForwardEntry forward, string testDir)
        {
            try
            {
                var sourcePath = Path.Combine(testDir, forward.SourceDll);
                var payloadPath = Path.Combine(testDir, forward.TargetDll);

                File.Copy(forward.FilePath, sourcePath, true);
                await CreateTestPayloadDllAsync(payloadPath);

                var testResult = await Task.Run(() =>
                {
                    var hModule = LoadLibrary(sourcePath);
                    if (hModule != IntPtr.Zero)
                    {
                        try
                        {
                            var procAddr = GetProcAddress(hModule, forward.SourceFunction);
                            return procAddr != IntPtr.Zero;
                        }
                        finally
                        {
                            FreeLibrary(hModule);
                        }
                    }
                    return false;
                });

                var payloadExecuted = File.Exists(Path.Combine(testDir, "payload_executed.txt"));
                return testResult && payloadExecuted;
            }
            catch
            {
                return false;
            }
        }

        private async Task CreateTestPayloadDllAsync(string outputPath)
        {
            var dllTemplate = Convert.FromBase64String(
                "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                "AAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBi" +
                "ZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAABQRQAAQAECAKY8lVwAAAAAAOAO" +
                "AgELAQgAHgAAADgBAAAYAAAAgAAAABAAAIAAAAAgAAAAAgAABAAAAAAAAAAEAAAA" +
                "AAAAAPABAAAEAAAAwAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAEAAMCDgAAA");

            await File.WriteAllBytesAsync(outputPath, dllTemplate);
        }

        private bool IsFileDigitallySigned(string filePath)
        {
            try
            {
                return File.Exists(filePath + ".sig") || HasValidSignature(filePath);
            }
            catch
            {
                return false;
            }
        }

        private bool HasValidSignature(string filePath)
        {
            try
            {
                using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);
                var buffer = new byte[8192];
                var sha256 = SHA256.Create();
                int bytesRead;
                while ((bytesRead = fs.Read(buffer, 0, buffer.Length)) > 0)
                {
                    sha256.TransformBlock(buffer, 0, bytesRead, null, 0);
                }
                sha256.TransformFinalBlock(new byte[0], 0, 0);
                return sha256.Hash.Take(4).All(b => b != 0);
            }
            catch
            {
                return false;
            }
        }

        public void GenerateReport(ScanResult result, string outputPath)
        {
            var report = new StringBuilder();
            report.AppendLine("DLL FORWARD SIDELOADING VULNERABILITY AUDIT REPORT");
            report.AppendLine($"Scan Timestamp: {result.ScanTimestamp:yyyy-MM-dd HH:mm:ss} UTC");
            report.AppendLine($"System Version: {result.SystemVersion}");
            report.AppendLine($"Files Scanned: {result.TotalFilesScanned}");
            report.AppendLine($"Scan Duration: {result.ScanDuration}");
            report.AppendLine($"Total Forwards Found: {result.AllForwards.Count}");
            report.AppendLine($"Vulnerable Forwards: {result.VulnerableForwards.Count}");
            report.AppendLine();

            if (result.VulnerableForwards.Any())
            {
                report.AppendLine("CRITICAL VULNERABILITIES:");
                foreach (var vuln in result.VulnerableForwards.Where(v => v.RiskLevel == "CRITICAL"))
                {
                    report.AppendLine($"  {vuln.SourceDll}::{vuln.SourceFunction} -> {vuln.TargetDll}::{vuln.TargetFunction}");
                }

                report.AppendLine("\nHIGH RISK VULNERABILITIES:");
                foreach (var vuln in result.VulnerableForwards.Where(v => v.RiskLevel == "HIGH"))
                {
                    report.AppendLine($"  {vuln.SourceDll}::{vuln.SourceFunction} -> {vuln.TargetDll}::{vuln.TargetFunction}");
                }

                report.AppendLine("\nTESTED EXPLOITS:");
                foreach (var test in result.TestedSideloads)
                {
                    report.AppendLine($"  {test.Key}: {(test.Value ? "EXPLOITABLE" : "SAFE")}");
                }
            }
            else
            {
                report.AppendLine("NO CRITICAL VULNERABILITIES DETECTED");
            }

            File.WriteAllText(outputPath, report.ToString());
        }
    }

    class Program
    {
        static async Task Main(string[] args)
        {
            var scanner = new VulnerabilityScanner();
            
            Console.WriteLine("Starting DLL Forward Sideloading vulnerability scan...");
            var result = await scanner.PerformFullSystemScanAsync();
            
            var reportPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), 
                                        $"DllForwardAudit_{DateTime.Now:yyyyMMdd_HHmmss}.txt");
            
            scanner.GenerateReport(result, reportPath);
            
            Console.WriteLine($"Scan complete. Report saved to: {reportPath}");
            Console.WriteLine($"Vulnerabilities found: {result.VulnerableForwards.Count}");
            Console.WriteLine($"Critical issues: {result.VulnerableForwards.Count(v => v.RiskLevel == "CRITICAL")}");
            
            if (args.Contains("--json"))
            {
                var jsonPath = reportPath.Replace(".txt", ".json");
                var json = System.Text.Json.JsonSerializer.Serialize(result, new System.Text.Json.JsonSerializerOptions 
                { 
                    WriteIndented = true 
                });
                await File.WriteAllTextAsync(jsonPath, json);
                Console.WriteLine($"JSON report saved to: {jsonPath}");
            }
        }
    }
}
